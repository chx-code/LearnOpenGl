## 深度测试

### 1. 常用接口
```c++
// 深度测试默认是禁用的，所以如果要启用深度测试的话，我们需要用GL_DEPTH_TEST选项来启用它
glEnable(GL_DEPTH_TEST);

// 如果你启用了深度缓冲，你还应该在每个渲染迭代之前使用GL_DEPTH_BUFFER_BIT来清除深度缓冲，否则你会仍在使用上一次渲染迭代中的写入的深度值：
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

// OpenGL允许我们禁用深度缓冲的写入,即为只读
glDepthMask(GL_FALSE);

// 深度测试函数的选择
/*
 * GL_ALWAYS	永远通过深度测试
 * GL_NEVER	永远不通过深度测试
 * GL_LESS	在片段深度值小于缓冲的深度值时通过测试
 * GL_EQUAL	在片段深度值等于缓冲区的深度值时通过测试
 * GL_LEQUAL	在片段深度值小于等于缓冲区的深度值时通过测试
 * GL_GREATER	在片段深度值大于缓冲区的深度值时通过测试
 * GL_NOTEQUAL	在片段深度值不等于缓冲区的深度值时通过测试
 * GL_GEQUAL	在片段深度值大于等于缓冲区的深度值时通过测试
 */
glDepthFunc(GL_LESS);
```

### 2. 深度值的计算
- 线性深度缓冲（基本不用）
```
Fdepth = (z - near) / (far - near)
```
- 非线性深度缓冲（和 1/z 成正比）
```
// 特点：z值很小的情况下提供了非常大的精度
Fdepth = (1/z - 1/near) / (1/far - 1/near)
```

### 3. 深度冲突（Z-fighting）原因及解决方案
- 原因
```text
    深度缓冲没有足够的精度来决定两个形状哪个在前面。结果就是这两个形状不断地在切换前后顺序
```
- 解决方案
```text
1. 永远不要把多个物体摆得太靠近，以至于它们的一些三角形会重叠。通过在两个物体之间设置一个用户无法注意到的偏移值；

2. 尽可能将近平面设置远一些.非线性深度缓冲,在z值很小的情况下提供了非常大的精度；

3. 使用更高精度的深度缓冲。大部分深度缓冲的精度都是24位的，但现在大部分的显卡都支持32位的深度缓冲，这将会极大地提高精度。所以，牺牲掉一些性能，你就能获得更高精度的深度测试，减少深度冲突。
```